namespace Newbe.BlogRenderer;

public static class PreDefinedContent
{
    public const string CopyrightTemplate = @"
- 本文作者： [newbe36524](https://www.newbe.pro)
- 本文链接： [https://www.newbe.pro/Others/%slag%/](https://www.newbe.pro/Others/%slag%/)
- 版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！";

    public const string EndingTemplate =
        @"
&&&&---default---
感谢您的阅读，如果您觉得本文有用，快点击下方赞同按钮👍，让更多的人看到本文。
&&&&---wechat---
感谢您的阅读，如果您觉得本文有用，快点击下方赞同按钮👍，让更多的人看到本文。
&&&&---cnblogs---
感谢阅读，如果觉得本文有用，不妨点击推荐👍或者在评论区留下 Mark，让更多的人可以看到。
&&&&---zhihu---
感谢您的阅读，如果您觉得本文有用，快点击下方赞同按钮👍，让更多的人看到本文。
&&&&---TencentCloud---
感谢您的阅读，如果您觉得本文有用，快点击下方点赞按钮👍，让更多的人看到本文。
&&&&---toutiao---
感谢您的阅读，如果您觉得本文有用，快点击下方点赞按钮♥️，让更多的人看到本文。
&&&&---infoq---
感谢您的阅读，如果您觉得本文有用，快点击下方点赞按钮👍，让更多的人看到本文。
&&&&---bilibili---
感谢您的阅读，如果您觉得本文有用，快长按右下角大拇指👍为本文点赞~
&&&&---juejin---
感谢您的阅读，如果您觉得本文有用，快点击下方点赞按钮👍，让更多的人看到本文。
&&&&---csdn---
感谢您的阅读，如果您觉得本文有用，快点击下方点赞按钮👍，让更多的人看到本文。
&&&&---aliyun---
感谢您的阅读，如果您觉得本文有用，快点击下方点赞按钮👍，让更多的人看到本文。
&&&&---sifou---
感谢您的阅读，如果您觉得本文有用，快点击下方点赞按钮👍，让更多的人看到本文。
";

    public const string AdTemplate = @"
&&&&---default---
> **可发帖可群聊的技术交流方式已经上线，欢迎通过链接，加入我们一起讨论。 <https://www.newbe.pro/links/>**
&&&&---wechat---
> 欢迎加入Q群 610394020，进入腾讯最新功能类Discord功能： QQ 频道。
> 在 QQ 频道中，你可以：
> - 在技术专区发帖求教
> - 在摸鱼频道畅快遨游
> - 在会议频道一同讨论
> 让我们一同打造和谐社区。
&&&&---cnblogs---
> 欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。
> ![关注微信公众号“newbe技术专栏”](https://www.newbe.pro/images/weixin_public_qrcode.png)
&&&&---zhihu---
> 欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。
> ![关注微信公众号“newbe技术专栏”](https://www.newbe.pro/images/weixin_public_qrcode.png)
> 欢迎加入Q群 610394020，进入腾讯最新功能类Discord功能： QQ 频道。
> 在 QQ 频道中，你可以：
> - 在技术专区发帖求教
> - 在摸鱼频道畅快遨游
> - 在会议频道一同讨论
> 让我们一同打造和谐社区。
&&&&---TencentCloud---
> 欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。
> ![关注微信公众号“newbe技术专栏”](https://www.newbe.pro/images/weixin_public_qrcode.png)
&&&&---toutiao---
> 欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。
> 欢迎加入Q群 610394020，进入腾讯最新功能类Discord功能： QQ 频道。
> 在 QQ 频道中，你可以：
> - 在技术专区发帖求教
> - 在摸鱼频道畅快遨游
> - 在会议频道一同讨论
> 让我们一同打造和谐社区。
&&&&---infoq---
> 欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。
> ![关注微信公众号“newbe技术专栏”](https://www.newbe.pro/images/weixin_public_qrcode.png)
&&&&---bilibili---
> 欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。
> ![关注微信公众号“newbe技术专栏”](https://www.newbe.pro/images/weixin_public_qrcode.png)
&&&&---juejin---
> 欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。
> ![关注微信公众号“newbe技术专栏”](https://www.newbe.pro/images/weixin_public_qrcode.png)
&&&&---csdn---
> 欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。
> ![关注微信公众号“newbe技术专栏”](https://www.newbe.pro/images/weixin_public_qrcode.png)
&&&&---aliyun---
> 欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。
> ![关注微信公众号“newbe技术专栏”](https://www.newbe.pro/images/weixin_public_qrcode.png)
&&&&---sifou---
> 欢迎关注作者的微信公众号“newbe技术专栏”，获取更多技术内容。
> ![关注微信公众号“newbe技术专栏”](https://www.newbe.pro/images/weixin_public_qrcode.png)
";

    public const string AiTemplate = @"
> 本内容采用人工智能辅助协作，经本人审核，符合本人观点与立场。";

    public const string TestMarkdown = @"---
                                         date: 2023-01-01
title: 在 C# 9 中使用 foreach 扩展
tags: [dotnet, chatOpenAI, C#]

cover: /images/newbe_cover (Small).png
slag: 0x013-Extension-foreach-in-csharp-9
summary: 在 C# 9 中，foreach 循环可以使用扩展方法。在本文中，我们将通过例子回顾 C# 9 中如何扩展 foreach 循环。

---

<!-- YamlFrontMatter -->

在 C# 9 中，foreach 循环可以使用扩展方法。在本文中，我们将通过例子回顾 C# 9 中如何扩展 foreach 循环。

<!-- more -->

## 代码演示

下面是一个对树形结构进行深度优先遍历的示例代码：

```csharp
using System;
using System.Collections.Generic;

namespace Example
{
    class TreeNode
    {
        public int Value { get; set; }
        public List<TreeNode> Children { get; set; }

        public TreeNode(int value)
        {
            Value = value;
            Children = new List<TreeNode>();
        }
    }

    static class TreeExtensions
    {
        public static IEnumerable<TreeNode> DepthFirst(this TreeNode root)
        {
            yield return root;
            foreach (var child in root.Children.SelectMany(DepthFirst))
            {
                yield return child;
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var root = new TreeNode(1);
            root.Children.Add(new TreeNode(2));
            root.Children.Add(new TreeNode(3));
            root.Children[0].Children.Add(new TreeNode(4));
            root.Children[0].Children.Add(new TreeNode(5));

            foreach (var node in root.DepthFirst())
            {
                Console.WriteLine(node.Value);
            }
            // Outputs: 1 2 4 5 3
        }
    }
}
```

在这个示例代码中，我们在 TreeNode 类中定义了一个值属性和一个存储子节点的列表属性。我们还在 TreeExtensions 类中定义了一个 DepthFirst 扩展方法，该方法使用 yield return 语句来返回树形结构的深度优先遍历结果。

在 Main 方法中，我们创建了一个树形结构，然后使用 foreach 循环来遍历树形结构的深度优先遍历结果。

之所以使用扩展方法往往是因为，我们可以在不修改 TreeNode 类的情况下，为 TreeNode 类添加新的功能。

那么接下来我们希望在 C# 9 中默认为 TreeNode 类添加 DepthFirst 行为，这样我们就可以直接使用 foreach 循环来遍历树形结构的深度优先遍历结果了。

## C# 9 中的 foreach 扩展

在 C# 9 中，我们可以使用 foreach 扩展来实现上面的需求。我们只需要在 TreeNode 类中添加一个 GetEnumerator 方法，该方法返回一个实现了 IEnumerable<TreeNode> 接口的对象即可。

```csharp
static class TreeExtensions
{
    public static IEnumerable<TreeNode> DepthFirst(this TreeNode root)
    {
        yield return root;
        foreach (var child in root.Children.SelectMany(DepthFirst))
        {
            yield return child;
        }
    }

    public static IEnumerator<TreeNode> GetEnumerator(this TreeNode root)
    {   
        return root.DepthFirst().GetEnumerator();
    }
}
```

在上面的代码中，我们在 TreeNode 类中添加了一个 GetEnumerator 方法，该方法返回一个实现了 IEnumerable<TreeNode> 接口的对象。这个对象就是我们在 DepthFirst 方法中使用 yield return 语句返回的结果。

现在我们可以直接使用 foreach 循环来遍历树形结构的深度优先遍历结果了。

```csharp
foreach (var node in root)
{
    Console.WriteLine(node.Value);
}
```

## 总结

在 C# 9 中，我们可以使用 foreach 扩展来为类添加新的行为。在上面的示例代码中，我们为 TreeNode 类添加了 DepthFirst 行为，这样我们就可以直接使用 foreach 循环来遍历树形结构的深度优先遍历结果了。

## 参考资料

- [Extension GetEnumerator support for foreach loops](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/extension-getenumerator?WT.mc_id=DX-MVP-5003606)[^1]

[^1]: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/extension-getenumerator?WT.mc_id=DX-MVP-5003606

<!-- md Chat-AI-Footer.md -->

<!-- ending -->

<!-- copyright-->
";
}